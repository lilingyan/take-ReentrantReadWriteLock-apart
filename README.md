# take-ReentrantReadWriteLock-apart

java的aqs原理其实非常简单  
就是线程去抢锁，抢到就执行，抢不到就挂起，
然后前面执行完了释放锁，按条件唤醒一下挂起的。  
唤醒里面有点文章，就是挂起的时候，会建一个争抢队列，
唤醒可以按不同策略，唤醒队列里面线程。  
就没了~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

最难的，是写这个的人太聪明了。
我们平时写代码，都是一段加个锁，哪怕有些代码可以线程不安全。  
但他作为框架的制定者，他的代码要最优化。
所以他把所有可能线程安全的地方都拆成了一个一个小的cas方法分散在各处，
然后这些小的线程安全方法环环相扣，
最终程序还是线程安全的(太天才了，无法描述，看完源码就能理解)。

网上找了好多好多文章，没有一篇能说全的。  
大部分只会翻译注释。。。也有一些看懂了，但是还是表达不清楚作者的全部意图。
自己看了好久，还有一些细节判断没看懂。整体拆解思想更是一头雾水。  
有完全看懂的大佬，好想交个朋友~~~

### aqs一些重要思想
    1. 它有许多冗余代码，为了就像synchronized锁升级思路差不多，
        因为很多时候涉及不到争抢，这样能提高大部分普通场景的效率。  
        比如会先去简单抢一下锁，如果不行，则去循环抢锁，  
        比如添加节点，先快速添加一下，如果失败了，再去循环cas添加  
        再比如读写锁的时候，它记录了第一次获取的，最后一次获取的线程，最后一次获取线程的重入次数计数器，
        其实这些也可以从ThreadLocal中获取。
    2. 非公平也不是绝对的  
        因为唤醒策略不是全部唤醒，重新去抢锁(即使这样，jvm层也不绝对)。
        而是只有旧线程唤醒，新线程加进来的时候，才会去抢，这时候才不公平，
        如果都在队列里，那就是公平了。
        读写锁更是，如果队列里面有读有写，并且一一相隔，那就变成普通的公平重入锁啦。

## 1. 最普通的锁  
    多个线程抢锁，只可能成功一个，剩下退出，
    以后不管谁，都无法获取到锁，直到那个线程释放
    
    这里使用了java自带的synchronized，其实原理都是一样的  
    抢锁，其实就是竞争去设值，谁要是成功了，那就认为是谁抢到了锁
    synchronized内部就是向对象头设置了一个线程id，当然我们也可以自己写个原子操作。
    在ReentrantLock中，大量使用到的是cas，不过他为了效率，是直接用c语言操作内存修改的。
    
## 2. 重入锁
    普通锁会有一个问题，如果一个方法递归自己，或者两个方法都要锁的方法
    在同一个线程里面，但是因为只能获取一次，那就不能执行了，非常不方便。
    重入的意思，就是一个线程获取锁后，
    他的内部可以无限制继续重复获取这个锁(当然，要看那个被赋值的对象是什么类型，一般用int有限制，当然也可以做成没限制的)
    ReentrantLock中有两种处理方式，一种是不公平重入锁，一种是公平重入锁。
+ 非公平  
    线程获取锁是直接去cas设值，如果设置失败，就建一个节点加入队列，然后挂起当前线程。
    前面的线程执行完后释放锁时，会去唤醒在头结点上的线程。
    但是后续线程进来还是先直接去抢锁，
    就会在这里有冲突，可能是节点上的线程抢到锁了，但也可能是刚进来那个线程，
    所以叫做非公平锁。
+ 公平
    与非公平锁非常像，只不过刚进来的线程抢锁有点小区别。
    线程进来抢锁的时候，会去判断，队列里面有没有节点，有节点就不用抢了，直接挂最后面。
    唤醒时一样的，只唤醒头节点。
    
## 3. 按条件唤醒锁(Condition)  
    这个和java自带的wait notify是一样的功能。ReentrantLock中的执行方法和jvm中基本一致(
    也是一个抢占队列，一个等待队列),
    不过jvm中功能开放较少，可用api不够处理复杂的问题(无法精确控制要唤醒哪几个)。
    ReentrantLock主要靠了LockSupport方法类，它可以指定线程去wait和notify。
    首先，我们先要实例化几个Condition(其实就是等待队列)。
    每次使用Condition中的等待方法，就会把当前线程挂起，然后在Condition的等待队列中创建一个标记节点。
    最后我们可以唤醒一个获取或者全部唤醒，唤醒一个就是把等待队列的头节点放到上面重入锁的争抢队列中，
    全部唤醒就是全部放过去，然后就走上面重入锁的流程了。
    ReentrantLock只做到这层，其实我们自己丰富一下，都可以精确指定要唤醒哪一个线程的。
    
## 4. 读写分离重入锁
    其实就是记录一下读重入几次，写重入几次。当然需要两个变量啦。
    ReentrantLock中取巧了，它把一个int拆成了高低位，当作了两个数，
    当然我们自己重写用两个值记录，也没什么问题。
    ReentrantLock支持在当前线程获取写锁的时候，再获取读锁。如果这个时候再释放写锁，叫做写锁降级。
    ReentrantLock中不支持读锁升级。
    ReentrantLock中只要写锁被拿了，除了重入读写，别的线程都不允许获取任何锁，
    如果读锁被拿了，那所有线程允许读，但是不允许写。
    
    道理其实和重入锁差不多，发现自己抢锁失败就进入队列。
    但它有一个最大的区别，就是重入锁只有在释放锁的时候，才会去唤醒抢占队列中的节点。
    而它的读锁，在执行的时候，会去唤醒一下后继结点，如果后继节点还是读锁，就会扩散下去。
    直到碰到写锁。
    